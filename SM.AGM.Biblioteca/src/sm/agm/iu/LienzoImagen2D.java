package sm.agm.iu;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.geom.Rectangle2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.ByteLookupTable;
import java.awt.image.ColorConvertOp;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.ConvolveOp;
import java.awt.image.DataBuffer;
import java.awt.image.Kernel;
import java.awt.image.LookupOp;
import java.awt.image.LookupTable;
import java.awt.image.RescaleOp;
import java.awt.image.WritableRaster;
import java.util.ArrayList;
import sm.agm.graficos.AGChessOP;
import sm.agm.graficos.AGDivisionOP;
import sm.agm.graficos.AGMultiplicationOP;
import sm.agm.graficos.AGRainbowOP;
import sm.agm.graficos.AGSepiaOP;
import sm.agm.graficos.AGSobelOP;
import sm.agm.graficos.AGUmbralizacionOP;
import sm.agm.graficos.ColorSpaceType;
import sm.agm.graficos.ImageFilterType;
import sm.agm.graficos.RainbowType;
import sm.image.BlendOp;
import sm.image.EqualizationOp;
import sm.image.KernelProducer;
import sm.image.LookupTableProducer;
import sm.image.SubtractionOp;
import sm.image.TintOp;
import sm.image.color.GreyColorSpace;

/**
 * Clase LienzoImagen2D
 * Un objeto de esta clase representa un lienzo en el que se pueden visualizar
 * imágenes. Hereda de Lienzo2D para obtener algunas de sus propiedades.
 * @author angel
 */
public class LienzoImagen2D extends Lienzo2D {

    /** 
     * Imagen actual
     */
    private BufferedImage img = null;
    
    /**
     * Copia de la imagen original, no se modifica
     */
    private BufferedImage imgCopy = null;
    
    /**
     * Copia de la imagen original, en esta copia se almacenan las transformaciones
     * que se le van haciendo a la imagen inicial.
     */
    private BufferedImage imgCopy2 = null;
    
    /**
     * Si se dibuja o no el marco discontinuo que delimita el lienzo
     */
    private boolean frame = true;
    
    /**
     * Si se está dibujando o no, usado para mostrar un fondo blanco en caso de dibujo
     */
    private boolean drawing = true;
    
    /**
     * Usado para la rotación, intento de evitar que se oculten las esquinas en la rotación
     */
    private float diagonal = 0;
    
    /**
     * Valor de tintado actual
     */
    private float tintValue = 0f;
    
    /**
     * Tipo de espacio de color de la imagen actual
     */
    private int colorSpace = -1;
    
    /**
     * Si la imagen tiene canal alfa o no
     */
    private boolean hasAlpha = false;
    
    /**
     * Valor del brillo actual
     */
    private int brightnessValue = 0;
    
    /**
     * Valor de la rotación actual
     */
    private int rotationValue = 0;
    
    /**
     * Tipo de filtro "Rainbow"
     */
    private RainbowType rainbowType = RainbowType.RGB;
    
    /**
     * Creates new form LienzoImagen2D
     */
    public LienzoImagen2D() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
 
    /**
     * Devuelve el valor de la rotación actual
     * @return Valor de la rotación actual
     */
    public int getRotationValue() { return rotationValue; }
    
    /**
     * Devuelve el valor del brillo actual
     * @return Valor del brillo actual
     */
    public int getBrightnessValue() { return brightnessValue; }

    /**
     * Devuelve el valor del tintado actual
     * @return Valor del tintado actual
     */
    public float getTintValue() { return tintValue; }

    /**
     * Asigna un tipo de filtro "Rainbow" y lo aplica.
     * @param rainbowType Nuevo tipo de filtrado "Rainbow"
     */
    public void setRainbowType(RainbowType rainbowType) {
        this.rainbowType = rainbowType;
        this.rainbow();
    }
        
    /**
     * Devuelve el espacio de color de la imagen actual.
     * @return Espacio de color de la imagen actual.
     */
    public int getColorSpaceType() { return colorSpace; }
    
    /**
     * Asigna si se tiene que dibujar o no el marco que delimita el lienzo
     * @param frame Si se tiene que dibujar o no el marco que delimita el lienzo
     */
    private void setFrame(boolean frame) { this.frame = frame; }
    
    /**
     * Asigna si se está dibujando o no, si es un lienzo de dibujo o de imagen
     * @param drawing Si es un lienzo de dibujo o de imagen
     */
    public void setDrawing(boolean drawing) { this.drawing = drawing; }
    
    /**
     * Devuelve la imagen actual.
     * @return Imagen actual
     */
    private BufferedImage getImg() { return img; }
    
    /**
     * Devuelve la iamgen dependiendo de si se quiere con las posibles figuras
     * dibujadas o sin ellas.
     * @param drawVector Si se quieren mostrar las figuras dibujadas o no.
     * @return La imagen dependiendo de drawVector
     */
    public BufferedImage getImg(boolean drawVector) {
        if (drawVector) {
            setFrame(false);
            BufferedImage aux = new BufferedImage(img.getWidth(), img.getHeight(), img.getType());
            paint(aux.createGraphics());
            return aux;
        } else {
            return getImg();
        }
    }

    /**
     * Asigna una imagen a la actual. Además hace copias de esta y obtiene su espacio de color
     * @param img Imagen a asignar
     */
    public void setImg(BufferedImage img) {
        if (img != null) {
            // Dimensiones del lienzo
            setPreferredSize(new Dimension(img.getWidth(), img.getHeight()));
            
            // Clip del lienzo
            setClip(new Rectangle2D.Float(0, 0, img.getWidth(), img.getHeight()));
            this.img = img;
            
            // Obtengo espacio de color
            int components = img.getColorModel().getColorSpace().getNumComponents();
            if (components == 1) colorSpace = ColorSpace.CS_GRAY;
            if (components == 3 && img.getColorModel().getColorSpace().isCS_sRGB()) colorSpace = ColorSpace.CS_sRGB;
            if (components == 3 && !img.getColorModel().getColorSpace().isCS_sRGB()) colorSpace = ColorSpace.CS_PYCC;
            
            // Obtengo si la imagen tiene canal alfa
            hasAlpha = img.getColorModel().hasAlpha();
            
            // Copias de la imagen
            if (imgCopy == null) {
                imgCopy = copyImage();
                imgCopy2 = copyImage();
            }
            
            // Calculo de diagonal, para la rotación
            if (diagonal == 0)
                diagonal = (float) Math.sqrt( Math.pow(img.getHeight(), 2) + Math.pow(img.getWidth(), 2) );
        }      
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (img != null) {
            g.drawImage(img, 0, 0, this);
            drawCanvas(g);
        }
    }
    
    /**
     * Dibujo "escenario", con fondo blanco en caso de ser un lienzo tradicional. Además
     * se dibuja el marco o no.
     * @param g Objeto Graphics usado para dibujar los diferentes elementos
     */
    private void drawCanvas(Graphics g) {
        Graphics2D g2d = (Graphics2D) g;
        
        // Pinto rectángulo blanco si es un dibujo
        if (drawing) {
            g2d.setColor(Color.WHITE);
            g2d.fillRect(0, 0, img.getWidth(), img.getHeight());
        }
        
        // Patrón (se desactiva al guardar el lienzo)
        if (frame) {
            g2d.setColor(Color.BLACK);
            float pattern[] = {5.0f};
            g2d.setStroke(new BasicStroke(1.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER, 10.0f, pattern, 0.0f));
            g2d.drawRect(0, 0, img.getWidth()-1, img.getHeight()-1);
        }
    }
    
    /**
     * Actualiza la imagen de copia 2
     */
    public void updateCopy() {
        imgCopy2 = copyImage();
        repaint();
    }
    
    /**
     * Aplica brillo a la imagen según valor
     * @param value Valor de brillo
     */
    public void applyBrightness(int value) {
        brightnessValue = value;
                
        try {
            // Cálculo de componentes y vectores            
            float brightness = (float) 1.0f + (value / 255.0f);
            float alpha = (float) Math.abs(value / 255.0f - 1.0f);

            // CS_sRGB
            float[] br = new float[] {brightness, brightness, brightness};
            float[] al = new float[] {0f, 0f, 0f};
            
            if (colorSpace == ColorSpace.CS_PYCC || hasAlpha) {
                br = new float[] {brightness, brightness, brightness, alpha};
                al = new float[] {0f, 0f, 0f, 0f};
            }
            
            if (colorSpace == ColorSpace.CS_GRAY) {
                br = new float[] {brightness};
                al = new float[] {0f};
            }
            
            // Operador
            RescaleOp rop = new RescaleOp(br, al, null);
            
            // Filtrado
            rop.filter(imgCopy2, getImg(false));
            repaint();
        } catch (IllegalArgumentException e) {
            System.err.println(e.getLocalizedMessage());
        }
    }
    
    /**
     * Aplica un filtro básico a la imagen
     * @param filter Tipo de filtro básico
     */
    public void applyFilter(ImageFilterType filter) {
        Kernel k = null;
        
        // Creo kernel según filtro
        switch(filter) {
            case HALFBLURRING: k = KernelProducer.createKernel(KernelProducer.TYPE_MEDIA_3x3); break;
            case BINOMIALBLURRING: k = KernelProducer.createKernel(KernelProducer.TYPE_BINOMIAL_3x3); break;
            case FOCUS: k = KernelProducer.createKernel(KernelProducer.TYPE_ENFOQUE_3x3); break;
            case LAPLACIANBORDERDETECTOR: k = KernelProducer.createKernel(KernelProducer.TYPE_LAPLACIANA_3x3); break;
            case RELIEF: k = KernelProducer.createKernel(KernelProducer.TYPE_RELIEVE_3x3); break;
        }

        // Aplico filtro
        if (k != null) {
            ConvolveOp cop = new ConvolveOp(k, ConvolveOp.EDGE_NO_OP, null);
            cop.filter(imgCopy2, getImg(false));
            updateCopy();
        }

        repaint();
    }
    
    /**
     * Aplica un contraste a la imagen según el tipo
     * @param type Tipo de contraste
     */
    public void applyContrast(int type) {
        try {
            LookupTable lt = LookupTableProducer.createLookupTable(type);
            LookupOp lop = new LookupOp(lt, null);
            lop.filter(getImg(false), getImg(false));
            updateCopy();
            repaint();
        } catch(Exception e) {
            System.err.println(e.getLocalizedMessage());
        }
    }
    
    /**
     * Aplica una escala a la imagen según valor
     * @param scale Valor de escalado de la imagen
     */
    public void scaleImage(float scale) {
        AffineTransform at = AffineTransform.getScaleInstance(scale, scale);
        AffineTransformOp atop = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        BufferedImage output = atop.filter(getImg(false), null);
        setImg(output);
        updateCopy();
        repaint();
    }
    
    /**
     * Rota la imagen según grados especificados
     * @param extent Grados que se quiere rotar la imagen
     */
    public void rotateImage(int extent) {
        rotationValue = extent;
        AffineTransform at = AffineTransform.getRotateInstance(Math.toRadians(extent), imgCopy2.getWidth() / 2, imgCopy2.getHeight() / 2);
        AffineTransformOp atop = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        BufferedImage output = atop.filter(imgCopy2, null);
        setImg(output);
        repaint();
    }   
    
    /**
     * Crea un LookupTable con una función sinusoidal a los píxeles de la imagen
     * @param w Valor a usar como referencia
     * @return LookupTable con la transformación
     */
    private LookupTable seno(double w) {
        double K = 255.0;
        byte[] lt = new byte[256];
        
        for (int i = 0; i < 256; ++i) {
            lt[i] = (byte) (K * Math.abs(Math.sin(Math.toRadians(w * i))));
        }
        
        return new ByteLookupTable(0, lt);
    }
    
    /**
     * Aplica una función sinusoidal a los píxeles de la imagen
     */
    public void sinFunction() {
        BufferedImage src = getImg(false);
        try {
            if (src != null) {
                LookupTable lt = seno(180f/255f);
                LookupOp lop = new LookupOp(lt, null);
                lop.filter(src, src);
                updateCopy();
                repaint();
            }
        } catch(Exception e) {
            System.err.println(e.getLocalizedMessage());
        }
    }
    
    /**
     * Obtiene la iBanda de una imagen
     * @param band Banda a extraer
     * @return Imagen en escala de grises representando la banda extraída
     */
    private BufferedImage getIBand(int band) {
        //Creamos el modelo de color de la nueva imagen basado en un espcio de color GRAY
        ColorSpace cs = new GreyColorSpace();
        ComponentColorModel cm = new ComponentColorModel(cs, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);

        //Creamos el nuevo raster a partir del raster de la imagen original
        int bandList[] = {band};
        WritableRaster bandRaster = (WritableRaster) getImg(false).getRaster().createWritableChild(0, 0, getImg(false).getWidth(), getImg(false).getHeight(), 0, 0, bandList);
        
        //Creamos una nueva imagen que contiene como raster el correspondiente a la banda
        return new BufferedImage(cm, bandRaster, false, null);
    }
    
    /**
     * Extrae todas las bandas de una imagen, según el tipo de imagen
     * @param cst Tipo de imagen
     * @return Vector de imágenes con las bandas
     */
    public ArrayList<BufferedImage> extractBands(int cst) {
        ArrayList<BufferedImage> imgs = new ArrayList<>();
        int index = 1;
        index = (cst == ColorSpace.TYPE_GRAY) ? 2 : 3;
        for (int i = 0; i < index; ++i)
            imgs.add(getIBand(i));
        
        return imgs;        
    }
    
    /**
     * Cambia una imagen de espacio de color y la devuelve.
     * @param cst Espacio de color al que se quiere cambiar
     * @return Imagen con el nuevo espacio de color
     */
    public BufferedImage changeColorSpace(ColorSpaceType cst) {
        BufferedImage output = null;
        ColorSpace cs = null;
        ColorConvertOp cop = null;
        
        switch(cst) {
            case GRAY:
                if (colorSpace == ColorSpace.CS_sRGB || colorSpace == ColorSpace.CS_PYCC) {
                    cs = new GreyColorSpace();
                    cop = new ColorConvertOp(cs, null);
                    output = cop.filter(img, null);
                }
                break;
                
            case RGB:
                if (colorSpace == ColorSpace.CS_GRAY || colorSpace == ColorSpace.CS_PYCC) {
                    cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
                    cop = new ColorConvertOp(cs, null);
                    output = cop.filter(img, null);
                }
                break;
                
            case YCC:
                if (colorSpace == ColorSpace.CS_GRAY || colorSpace == ColorSpace.CS_sRGB) {
                    cs = ColorSpace.getInstance(ColorSpace.CS_PYCC);
                    cop = new ColorConvertOp(cs, null);
                    output = cop.filter(img, null);
                }
                break;
        }
        
        return output;
    }
    
    /**
     * Aplica un tintado a la imagen. Usa el color de trazado y valor seleccionados
     * @param color Color con el que se aplica el tintado
     * @param value Valor/intensidad del tintado
     */
    public void tint(Color color, float value) {
        tintValue = value;
        TintOp tint = new TintOp(color, tintValue);
        tint.filter(imgCopy, getImg(false));
    }
    
    /**
     * Ecualiza el color de la imagen
     */
    public void equalize() {
        EqualizationOp eq = new EqualizationOp();
        eq.filter(getImg(false), getImg(false));
        updateCopy();
    }
    
    /**
     * Aplica un filtrado sepia
     */
    public void sepia() {
        AGSepiaOP sepia = new AGSepiaOP();
        sepia.filter(getImg(false), getImg(false));
        updateCopy();
    }
    
    /**
     * Umbraliza los píxeles de la imagen
     * @param value Valor de umbralización
     */
    public void umbralizar(int value) {
        AGUmbralizacionOP umbral = new AGUmbralizacionOP(value);
        umbral.filter(imgCopy2, getImg(false));
        updateCopy();
    }

    /**
     * Suma la foto actual con la que se pasa como argumento
     * @param dest Imagen que se suma a la actual
     * @return Suma de las imagenes
     */
    public BufferedImage add(BufferedImage dest) {
        BufferedImage output = null;
        try {
            BlendOp blop = new BlendOp(img);
            output = blop.filter(dest, null);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getLocalizedMessage());
        }
        
        return output;
    }
    
    /**
     * Resta la foto actual con la que se pasa como argumento
     * @param dest Imagen que se resta a la actual
     * @return Resta de las imagenes
     */
    public BufferedImage subtract(BufferedImage dest) {
        BufferedImage output = null;
        try {
            SubtractionOp subop = new SubtractionOp(getImg(false));
            output = subop.filter(dest, null);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getLocalizedMessage());
        }
        
        return output;
    }
    
    /**
     * Multiplica la foto actual con la que se pasa como argumento
     * @param dest Imagen que se multiplica a la actual
     * @return Multiplicación de las imagenes
     */
    public BufferedImage multiply(BufferedImage dest) {
        BufferedImage output = null;
        try {
            AGMultiplicationOP mult = new AGMultiplicationOP(getImg(false));
            output = mult.filter(dest, null);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getLocalizedMessage());
        }
        
        return output;
    }
    
    /**
     * Divide la foto actual con la que se pasa como argumento
     * @param dest Imagen que se divide a la actual
     * @return División de las imagenes
     */
    public BufferedImage divide(BufferedImage dest) {
        BufferedImage output = null;
        try {
            AGDivisionOP mult = new AGDivisionOP(getImg(false));
            output = mult.filter(dest, null);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getLocalizedMessage());
        }
        
        return output;
    }
    
    /**
     * Aplica una operación de sobel a la imagen
     */
    public void sobel() {
        AGSobelOP sobel = new AGSobelOP();
        sobel.filter(getImg(false), getImg(false));
        updateCopy();
    }
        
    /**
     * Aplica una trans
     */
    public void rainbow() {
        AGRainbowOP rainbow = new AGRainbowOP(rainbowType);
        rainbow.filter(imgCopy2, getImg(false));
    }
    
    /**
     * Crea un LookupTable con una función matemática a los píxeles de la imagen
     * @return LookupTable con la transformación
     */
    private LookupTable flor() {
        double K = 255.0;
        byte[] lt = new byte[256];
        
        for (int i = 0; i < 256; ++i) {
            lt[i] = (byte) (K * (1 + 0.9 * Math.cos(i)) * (1 + 0.1 * Math.cos(24 * i)) * (0.9 + 0.05 * Math.cos(200 * i)) * (1 + Math.sin(i)));
        }
        
        return new ByteLookupTable(0, lt);
    }
    
    /**
     * Aplica una transformación "flor" a la imagen. Se llama flor porque la 
     * función matemática representada en el plano con valores de -PI a PI dibuja
     * una "flor".
     */
    public void florFunction() {
        BufferedImage src = getImg(false);
        try {
            if (src != null) {
                LookupTable lt = flor();
                LookupOp lop = new LookupOp(lt, null);
                lop.filter(src, src);
                updateCopy();
                repaint();
            }
        } catch(Exception e) {
            System.err.println(e.getLocalizedMessage());
        }
    }
    
    /**
     * Aplica un filtrado a la imagen que divide la divide en cuadrantes y los
     * desordena
     * @param sides Número de cuadrantes por lado
     */
    public void chess(int sides) {
        AGChessOP chess = new AGChessOP(sides);
        chess.filter(getImg(false), getImg(false));
        updateCopy();
    }
    
    /**
     * Devuelve una copia de la imagen actual
     * @return Copia de la imagen actual
     */
    public BufferedImage copyImage() {
        ColorModel cm = img.getColorModel();
        WritableRaster wr = img.copyData(null);
        boolean alphapre = img.isAlphaPremultiplied();
        return new BufferedImage(cm, wr, alphapre, null);
    }

    @Override
    public void setEdit(boolean edit) { super.setEdit(edit); }

    @Override
    public boolean edit() { return super.edit(); }
   

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
