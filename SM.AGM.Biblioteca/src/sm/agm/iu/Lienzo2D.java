package sm.agm.iu;

import java.awt.*;
import java.awt.geom.*;
import java.util.ArrayList;
import sm.agm.graficos.*;
import sm.agm.lienzomanager.*;

/**
 * Clase Lienzo2D
 * Un objeto de esta clase representa un lienzo en el que se pueden dibujar
 * figuras.
 * @author angel
 */
public class Lienzo2D extends javax.swing.JPanel {
    
    /**
     * Vector de eventos
     */
    ArrayList<LienzoListener> lienzoEventListeners = new ArrayList();
    
    /**
     * Herramienta actual
     */
    private Tool tool = Tool.NONE;
    
    /**
     * Si se está editando o no
     */
    private boolean edit = false;
    
    /**
     * Posición actual del cursor
     */
    private Point2D mousePosition = new Point2D.Float(-10, -10);
    
    /**
     * Posición final del cursor tras arrastrarlo
     */
    private Point2D mousePositionEnd = new Point2D.Float(-10, -10);
    
    /**
     * Posición referencia del cursor
     */
    private final Point mouseRef = new Point(-10, -10);
    
    /**
     * Vector que almacena todas las formas dibujadas
     */
    protected ArrayList<AGShape> vShape = new ArrayList();
    
    /**
     * Figura actual
     */
    private AGShape currentShape;
    
    /**
     * Clip, área de trabajo
     */
    private Shape clip;
    
    /**
     * Paso de dibujo, usado para dibujar figuras en varios pasos
     */
    private int drawStep = 0;
    
    /**
     * Atributos actuales
     */
    private ComplexShapeAtributes atbs;
    
    /**
     * Creates new form Lienzo2D
     */
    public Lienzo2D() {
        initComponents();
    }
    
    /**
     * Agrega el listener de eventos
     * @param evt Listener de eventos
     */
    public void addLienzoListener(LienzoListener evt) {
        if (evt != null) lienzoEventListeners.add(evt);
    }
    
    /**
     * Notifica al listener que se ha agregado una figura
     * @param evt Evento registrado
     */
    private void notifyShapeAddedEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty())
            for (LienzoListener listener: lienzoEventListeners)
                listener.shapeAdded(evt);
    }
    
    /**
     * Notifica al listener que se ha seleccionado una figura
     * @param shape Figura seleccionada
     */
    public void notifyShapeSelectedEvent(AGShape shape) {
        LienzoEvent evt = new LienzoEvent(this, shape);
        if (!lienzoEventListeners.isEmpty())
            for (LienzoListener listener: lienzoEventListeners)
                listener.shapeSelected(evt);
    }

    /**
     * Devuelve el vector de figuras.
     * @return Vector de figuras.
     */
    public ArrayList<AGShape> getvShape() {
        return vShape;
    }
    
    /**
     * Activa o desactiva la edición en el lienzo (poder mover o no figuras) 
     * @param edit Si se quiere editar o no
     */
    public void setEdit(boolean edit) { this.edit = edit; }

    /**
     * Devuelve si se está en modo edición o no.
     * @return Si se está en modo edición o no.
     */
    public boolean edit() { return edit; }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();

        setBackground(new java.awt.Color(255, 255, 255));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        setLayout(new java.awt.BorderLayout());
        add(jScrollPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        mousePositionEnd = evt.getPoint();
        if (edit) editShape();
        else updateShape();
        
        repaint();
    }//GEN-LAST:event_formMouseDragged

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        mousePosition = evt.getPoint();
        if (!edit)
            createShape();
        else {
            selectShape();
            if (currentShape != null) {
                mouseRef.setLocation(currentShape.getBounds2D().getX(), currentShape.getBounds2D().getY());
            }
        }
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        mousePositionEnd = evt.getPoint();
        setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
        ++drawStep;
        resetDrawStep();
        repaint();
    }//GEN-LAST:event_formMouseReleased

    /**
     * Devuelve la figura que está seleccionada actualmente.
     * @return Figura que está seleccionada actualmente.
     */
    public Shape getCurrentShape() {
        return currentShape;
    }
    
    /**
     * Asigna el vector que se quiere usar en un instante dado
     * @param c Nuevo cursor que se quiere usar.
     */
    public void setCurrentCursor(Cursor c) { setCursor(c); }
    
    /**
     * Deselecciona la figura que estaba seleccionada.
     */
    public void deselectCurrentShape() {
        if (currentShape != null) {
            getCurrentShapeAtributes().setSelected(false);
            currentShape = null;
        }
    }
    
    /**
     * Selecciona la figura cuyo boundingbox se encuentra en la posición actual del cursor.
     */
    public void selectShape() {        
        if (currentShape != null) deselectCurrentShape();
        currentShape = getSelectedShape(mousePosition);
        if (currentShape != null) getCurrentShapeAtributes().setSelected(true);
        else tool = Tool.NONE;
    }
    
    /**
     * Devuelve la posición final del cursor, cuando se ha arrastrado el mismo.
     * @return Posición final del cursor, cuando se ha arrastrado el mismo.
     */
    public Point2D getCurrentMousePosition() { return mousePositionEnd; }
    
    /**
     * Devuelve si hay una figura seleccionada.
     * @return Si hay una figura seleccionada.
     */
    public boolean thereIsCurrentShape() { return currentShape != null; }
    
    /**
     * Devuelve los atributos de la figura pasada como argumento.
     * @param shape Figura a obtener sus atributos.
     * @return Atributos de la figura.
     */
    public Atributes getShapeAtributes(Shape shape) {
        Atributes atb = null;
        if (shape instanceof AGPoint)
            return ((AGPoint) shape).getAtributes();
        else if (shape instanceof AGLine)
            return ((AGLine) shape).getAtributes();
        else if (shape instanceof AGRectangle)
            return ((AGRectangle) shape).getAtributes();
        else if (shape instanceof AGEllipse)
            return ((AGEllipse) shape).getAtributes();
        else if (shape instanceof AGRoundRectangle)
            return ((AGRoundRectangle) shape).getAtributes();
        else if (shape instanceof AGArc)
            return ((AGArc) shape).getAtributes();
        else if (shape instanceof AGCubicCurve)
            return ((AGCubicCurve) shape).getAtributes();
        else if (shape instanceof AGQuadCurve)
            return ((AGQuadCurve) shape).getAtributes();
        else if (shape instanceof AGPath)
            return ((AGPath) shape).getAtributes();
        
        return atb;
    }
    
    /**
     * Devuelve los límites de la figura actual, su boundingbox.
     * @return Límites de la figura actual, su boundingbox.
     */
    public Rectangle2D getCurrentShapeBounds() {
        return currentShape.getBounds2D();
    }
    
    /**
     * Devuelve los atributos de la figura actual.
     * @return Atributos de la figura actual.
     */
    public Atributes getCurrentShapeAtributes() {
        return getShapeAtributes(currentShape);
    }

    /**
     * Devuelve la herramienta que está activada actualmente.
     * @return Herramienta que está activada actualmente.
     */
    public Tool getTool() {
        return tool;
    }

    /**
     * Asigna la figura que se quiere usar.
     * @param tool Figura que se quiere usar.
     */
    public void setTool(Tool tool) {
        this.tool = tool;
    }
    
    /**
     * Selecciona la figura pasada como argumento.
     * @param shape Figura que se quiere seleccionar.
     */
    public void selectAGShape(AGShape shape) {
        if (shape instanceof AGArc)
            ((AGArc) shape).getAtributes().setSelected(true);
        if (shape instanceof AGCubicCurve)
            ((AGCubicCurve) shape).getAtributes().setSelected(true);
        if (shape instanceof AGEllipse)
            ((AGEllipse) shape).getAtributes().setSelected(true);
        if (shape instanceof AGLine)
            ((AGLine) shape).getAtributes().setSelected(true);
        if (shape instanceof AGPath)
            ((AGPath) shape).getAtributes().setSelected(true);
        if (shape instanceof AGRectangle)
            ((AGRectangle) shape).getAtributes().setSelected(true);
        if (shape instanceof AGPoint)
            ((AGPoint) shape).getAtributes().setSelected(true);
        if (shape instanceof AGQuadCurve)
            ((AGQuadCurve) shape).getAtributes().setSelected(true);
        if (shape instanceof AGRoundRectangle)
            ((AGRoundRectangle) shape).getAtributes().setSelected(true);
        
        currentShape = shape;
    }
    
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        
        // Área de trabajo / clip
        if (clip != null)
            ((Graphics2D) g).clip(clip);
        
        for (Shape s: vShape)
            ((AGShape) s).draw((Graphics2D) g);
    }    
    
    /**
     * Elimina la figura actual del vector de figuras.
     */
    public void deleteCurrentShape() {
        vShape.remove(currentShape);
    }
    
    /**
     * Devuelve los atributos previos, los que son seleccionados previa creación de una figura
     * @return Atributos previos a la creación de una figura.
     */
    public Atributes getPrevAtributes() { return atbs; }
    
    /**
     * Asigna los atributos previos.
     * @param atbs Nuevos atributos previos.
     */
    public void setPrevAtributes(Atributes atbs) {
        this.atbs = (ComplexShapeAtributes) atbs;
    }
    
    /**
     * Devuelve el cursor se encuentra dentro del área de trabajo.
     * @return Si el cursor se encuentra dentro del área de trabajo.
     */
    private boolean mouseInClip() {
        return mousePosition.getX() <= clip.getBounds2D().getMaxX() && mousePosition.getY() <= clip.getBounds2D().getMaxY();
    }
    
    /**
     * Crea una forma en función de la herramienta y del tipo de figura.
     */
    private void createShape() {
        // Cursor para crear figuras
        setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
        
        // Deselecciono la figura actual si la hay
        if (currentShape != null) getCurrentShapeAtributes().setSelected(false);
        
        // Si el cursor está dentro del área de trabajo / clip
        if (mouseInClip()) {
            // Si drawStep es 0 se crean por defecto las figuras, se le pasan como argumento los atributos actuales
            if (drawStep == 0) {
                switch(tool) {
                    case POINT: 
                        currentShape = new AGPoint(mousePosition, atbs);
                        vShape.add(currentShape);
                        break;

                    case LINE:
                        currentShape = new AGLine(mousePosition, mousePosition, atbs);
                        vShape.add(currentShape);
                        break;

                    case RECTANGLE:
                        currentShape = new AGRectangle((Point) mousePosition, atbs);
                        vShape.add(currentShape);
                        break;

                    case ELLIPSE:
                        currentShape = new AGEllipse(mousePosition, atbs);
                        vShape.add(currentShape);
                        break;

                    case ROUNDRECTANGLE:
                        currentShape = new AGRoundRectangle(mousePosition, atbs);
                        vShape.add(currentShape);
                        ++drawStep;
                        break;

                    case ARC:
                        currentShape = new AGArc(mousePosition, atbs);
                        vShape.add(currentShape);
                        ++drawStep;
                        break;

                    case QUADCURVE:
                        currentShape = new AGQuadCurve(mousePosition, mousePosition, atbs);
                        vShape.add(currentShape);
                        ++drawStep;
                        break;

                    case CUBICCURVE:
                        currentShape = new AGCubicCurve(mousePosition, mousePosition, atbs);
                        vShape.add(currentShape);
                        ++drawStep;
                        break;

                    case PATH:
                        currentShape = new AGPath(mousePosition, atbs);
                        vShape.add(currentShape);
                        break;
                }
            }
            
            // Se notifica que se ha creado una figura
            notifyShapeAddedEvent(new LienzoEvent(this, (AGShape) currentShape));
        }
    }
    
    /**
     * Cambia la posición de la figura seleccionada.
     */
    private void editShape() {
        // Cursor para mover
        setCursor(new Cursor(Cursor.MOVE_CURSOR));
        
        // Punto de referencia // (0,0) = (p1.x, p1.y)
        Point p = new Point((int) mouseRef.getX() + (int) mousePositionEnd.getX() - (int) mousePosition.getX(), (int) mouseRef.getY() + (int) mousePositionEnd.getY() - (int) mousePosition.getY());
        
        if (currentShape instanceof AGPoint) {
            ((AGPoint) currentShape).setLocation(p);
        } else if (currentShape instanceof AGLine) {
            Point paux = p;
            Point bounds = ((AGLine) currentShape).getBounds().getLocation();
            
            // El punto de referencia es distinto según como se haya dibujado la línea
            // (0,0) = (p1.x, p1.y - height)
            if (bounds.getX() == ((AGLine) currentShape).getX1() && bounds.getY() == (((AGLine) currentShape).getY1() - ((AGLine) currentShape).getBounds2D().getHeight()))
                paux = new Point((int) p.getX(), (int) p.getY() + (int) ((AGLine) currentShape).getBounds2D().getHeight());

            // (0,0) = (p2.x, p2.y)
            else if (bounds.getX() == ((AGLine) currentShape).getX2() && bounds.getY() == ((AGLine) currentShape).getY2())
                paux = new Point((int) p.getX() + (int) ((AGLine) currentShape).getBounds2D().getWidth(), (int) p.getY() + (int) ((AGLine) currentShape).getBounds2D().getHeight());

            // (0,0) = (p2.x, p2.y - height)
            else if (bounds.getX() == ((AGLine) currentShape).getX2() && bounds.getY() == (((AGLine) currentShape).getY2() - ((AGLine) currentShape).getBounds2D().getHeight()))
                paux = new Point((int) p.getX() + (int) ((AGLine) currentShape).getBounds2D().getWidth(), (int) p.getY());

            ((AGLine) currentShape).setLocation(paux);
        } else if (currentShape instanceof AGRectangle) {
            ((AGRectangle) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGEllipse) {
            ((AGEllipse) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGRoundRectangle) {
            ((AGRoundRectangle) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGArc) {
            ((AGArc) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGQuadCurve) {
            ((AGQuadCurve) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGPath) {
            ((AGPath) currentShape).setLocation(p);
        } else if  (currentShape instanceof AGCubicCurve) {
            ((AGCubicCurve) currentShape).setLocation(p);
        }
        
        // Actualizo los límites de la figura en sus propiedades.
        getCurrentShapeAtributes().setBounds(currentShape.getBounds2D());
    }
    
    /**
     * Actualiza el tamaño de las figuras. Usado justo tras crear una figura para darle alto y ancho
     */
    private void updateShape() {
        // Cursor para dar forma a las figuras
        setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
        
        // Si he creado la figura
        if (currentShape != null) {
            // Si el cursor está dentro del área de trabajo
            if (mouseInClip()) {
                switch(tool) {
                    // Dibujar líneas, rectángulos, elipses y trazados libres solo requiere de un paso
                    case LINE: ((AGLine)currentShape).setLine(mousePosition, mousePositionEnd); break;
                    case RECTANGLE: ((Rectangle)currentShape).setFrameFromDiagonal(mousePosition, mousePositionEnd); break;
                    case ELLIPSE: ((Ellipse2D)currentShape).setFrameFromDiagonal(mousePosition, mousePositionEnd); break;
                    case PATH: ((AGPath)currentShape).addPoint((int) mousePositionEnd.getX(), (int) mousePositionEnd.getY()); break;
                    
                    // El rectángulo redondeado requiere de dos pasos
                    // En el primer paso se crea un rectángulo al igual que el rectángulo normal
                    // En el segundo paso se asigna el ancho y alto del arco, manteniendo el click izquierdo y arrastrando de arriba a abajo y de izquierda a derecha
                    case ROUNDRECTANGLE:
                        if (drawStep == 1) ((AGRoundRectangle)currentShape).setFrameFromDiagonal(mousePosition, mousePositionEnd);
                        else if (drawStep == 2) {
                            ((AGRoundRectangle)currentShape).setArchWidth((float) (mousePositionEnd.getX()% 360));
                            ((AGRoundRectangle)currentShape).setArchHeight((float) (mousePositionEnd.getY() % 360));
                        }
                        break;

                    // La curva con 1 punto requiere de dos pasos
                    // En el primer paso se crea una línea de la misma manera que una línea normal
                    // En el segundo paso se clicka y arrastra el ratón, asignándose la posicion de este como punto de control
                    case QUADCURVE:
                        if (drawStep == 1) ((AGQuadCurve)currentShape).setCurve(mousePosition, mousePosition, mousePositionEnd);
                        else if (drawStep == 2) ((AGQuadCurve)currentShape).setControlPoint(mousePositionEnd);
                        break;

                    // La curva con 2 puntos requiere de tres pasos
                    // En el primer paso se crea una línea de la misma manera que una línea normal
                    // En el segundo paso se clicka y arrastra el ratón, asignándose la posicion de este como primer punto de control
                    // En el tercer paso se clicka y arrastra el ratón, asignándose la posicion de este como segnudo punto de control
                    case CUBICCURVE:
                        if (drawStep == 1) ((AGCubicCurve)currentShape).setCurve(mousePosition, mousePosition, mousePosition, mousePositionEnd);
                        else if (drawStep == 2) ((AGCubicCurve)currentShape).setControlPoint1(mousePositionEnd);
                        else if (drawStep == 3) ((AGCubicCurve)currentShape).setControlPoint2(mousePositionEnd);
                        break;

                    // El arco requiere de tres pasos
                    // En el primer paso se crea el boundingbox del arco, como si de una elipse se tratara
                    // En el segundo paso se clicka y arrastra el ratón de arriba a abajo, asignándose el ángulo del arco
                    // En el tercer paso se clicka y arrastra el ratón de arriba a abajo, asignándose el comienzo del arco
                    case ARC:
                        if (drawStep == 1) ((AGArc)currentShape).setFrameFromDiagonal(mousePosition, mousePositionEnd);
                        else if (drawStep == 2) ((AGArc)currentShape).setAngle((float) (mousePositionEnd.getY() % 360));
                        else if (drawStep == 3) ((AGArc)currentShape).setStart((float) (mousePositionEnd.getY() % 360));
                        break;
                }
            
                // Selecciona la figura actual
                getCurrentShapeAtributes().setSelected(true);
                
                // Actualiza el boundingbox de la figura en sus atributos
                getCurrentShapeAtributes().setBounds(currentShape.getBounds2D());
            }
        }
        
        repaint();
    }
    
    /**
     * Resetea el drawstep una vez se ha terminado de dibujar las figuras
     */
    public void resetDrawStep() {
        // POINT, LINE, ELLIPSE, RECTANGLE y PATH
        if (tool != Tool.ARC && tool != Tool.ROUNDRECTANGLE && tool != Tool.QUADCURVE && tool != Tool.CUBICCURVE)        
            drawStep = 0;
        else if (tool == Tool.CUBICCURVE || tool == Tool.ARC){
            if (drawStep > 3) drawStep = 0;
        } else { // ROUNDRECTANGLE y QUADCURVE
            if (drawStep > 2) drawStep = 0;
        }
    }   
 
    /**
     * Devuelve la figura en la que el punto indicado se encuentra dentro de su boundingbox.
     * Recorre el vector de forma inversa para seleccionar antes lo que se haya pintado más recientemente.
     * @param p Punto de referencia del cursor
     * @return Figura seleccionada
     */
    private AGShape getSelectedShape(Point2D p) {
        for (int i = vShape.size() - 1; i >= 0; --i)
            if (vShape.get(i).contains(p)) return vShape.get(i);
        return null;
    }

    /**
     * Asigna el área de trabajo, el clip
     * @param clip Área de trabajo
     */
    public void setClip(Shape clip) { this.clip = clip; }
    
    /**
     * Asigna la forma actual
     * @param s Nueva forma actual
     */
    public void setCurrentShape(AGShape s) { currentShape = s; }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
